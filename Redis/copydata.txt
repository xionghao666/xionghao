redis主从复制
1. 配从不配主

2. 从库配置命令： slaveof ip port

3. 配置文件细节：
a. 拷贝多个redis.conf 文件，用于从不同端口启动
b. 开启 daemonize yes(进程守护模式)
c. 修改pid文件名
d. 不同配置文件指定不同端口号
e. 不同配置文件指定不同log文件名
f. 不同配置文件指定不同dump.rdb文件名

info replication : 查看当前redis信息

1主2从结构 ： 主机挂了重启后继续作为主机，从机挂了后重启不再作为从机，除非写入配置文件，主写从读

接力续传 ： 从库也可以作为其他redis的主库，演变成链式结构，去中心化

反客为主 ： slaveof no one (停止接受主库同步数据，可以转变成为主库)

复制原理 ： slave启动成功后连接到master后会发送一个sync命令，master收到命令启动后台存盘进程，同时收集
           所有接受到用于修改数据的的命令，在后台进程执行完毕后，master将传送整个数据文件到slave，以完成同步数据

全量复制 ： slave 服务在接受到数据文件后，将其存盘在全部加载到内存中
增量复制 ： master 继续将新的所有收集到写入命令依次传给slave完成同步，但是只要重新连接master，全量复制同步数据将会执行

哨兵模式 ： 反客为主的自动版
在redis目录下新建 sentinel.conf 
文件内容 ： sentinel monitor testname ip prot 1
启动哨兵 ： redis-sentinel /..../sentinel.conf

主库挂了，会通过投票选出新的主库，旧的主库重新上线后会被更新成为slave
还可以一组 sentinel 同时监控多个master
不过这种主从复制模式有数据延时的特点，在网络环境差的情况下会比较明显

无论如何保证服务高可用是第一大要求

A 缓存穿透(查不到数据) ： redis中查询不到数据，去数据库依然查不到数据，大量请求直接打到db
  解决方案 ： 缓存空对像直接返回，或者直接返回空，增加查询过滤例如 布隆过滤器

B 缓存击穿(热点数据过期) ： 非常热门的key处理大量的请求，这个key突然过期失效了，请求全部打到db。
  解决方案 ： 热点数据增加过期时间，或者给db处理请求加上互斥锁，保证对于当前key的处理只有一个线程去查询db，其他无权限的等待，查到后立即加入缓存

C 缓存雪崩 ： 大量缓存数据集体失效，redis 挂了
  解决方案 ： 缓存时间设置随机值不要同时失效，通过加锁控制读数据库写入缓存的线程数量，数据预热提前写入缓存，redis高可用使用集群，或者切换备用缓存服务器（服务降级，非主要业务暂停）   