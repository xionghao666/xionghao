blob 和 text类型
都是为了存储很大的数据而设计的字符串数据类型。分别采用二进制和字符方式存储

实际上它们分别属于两组不同的数据类型家族

字符类型: tinytext, smalltext, text, medium text, longtext
二进制类型: tniyblob, smallblob, blob, mediumblob, longblob,

与其他类型不同，mysql把每个 blob 和 text 当作一个独立的对象处理。
存储引擎在存储时通常会做特殊处理，当bolb和text值太大时，InnoDB会使用专门的“外部”存储区来进行存储，
此时每个值在行内需要1～4个字节存储一个指针，然后在外部存储区域存储实际的值

磁盘临时表和文件排序

如果查询使用了bolb和text列并且需要使用隐式临时表，将不得不使用myisam磁盘临时表即使只有几行数据也是如此
最好的解决方案是在所有用到bolb字段的地方都使用substring(column,length)将列值转换为字符串，
这样姐可以使用内存临时表啦但要确保截取的字符串足够短，不会使临时表的大小超过max_heap_table_size 
或tmp_table_size,超过以后mysql 会将内存临时表转换为myisam 磁盘临时表

使用枚举类型代替字符串类型
枚举列可以吧一些不重复的字符串存储成一个预定义的集合，mysql在存储枚举时非常紧凑，会根据列表值的数量
压缩到一个或者两个字节。

mysql内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字 - 字符串”映射的关系查找表
所以枚举的值尽量不要是 1，2，3这种整数，双重性很容易导致混乱

当把varchar 换为 enum ：两个 enum列的关联 明显比 两个 varchar的列关联更加快
转换后主键大小也会变小，减少主键索引也会使非主键索引变的更小

日期和时间类型
DATETIME ：从1001年 到 9999年，精度为秒。他把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中
与时区无关。使用8个字节存储空间

TIMESTAMP：从1970年0101午夜以来的秒数，他和UNIX时间戳相同。只使用4个字节。
mysql提供函数 FROM_UNIXTIME() 函数把时间戳转换为日期 UNIX_TIMESTAMP把日期转换为unix时间戳 
通常应该使用TIMESTAMP，他比DATETIME空间效率更高。
可以使用BIGINT类型存储微秒级别的时间截

位数据类型

BIT：在mysql5.0之前，BIT是TINYINT的同义词，BIT列的最大长度是64个位
BIT的行为因存储引擎而异，mysql把BIT当作字符串类型而不是数字类型

SET：如果需要保存很多true/false值，可以考虑合并这些列到一个SET数据类型，他在mysql内部是以一系列
打包的位的集合来表示。缺点改变列的定义的代价较高：需要 ALTER TABLE 这种操作对大表来说十分昂贵。
一种代替SET的方式是使用一个整数包装一系列的位。

特殊类型的数据：
某些类型的数据并不直接与内置类型一致，低于秒级精度的时间戳就是一个例子
或者ipv4地址，人们经常用varchar(15)来存储,他实际上是32位无符号整数，不是字符串，所以应该用无符号
整数来存储，小数点只是让人们更加容易阅读。 INET_ATON(),INET_NTOA()转化IP地址函数

mysql schema 设计中的陷阱
太多的列：mysql的存储引擎API工作时需要在服务器和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容
解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。
定长行结构不需要转变，变长需要。

太多的关联：mysql 限制每个关联最多只能有61张表，要想查询更快最好控制在12 个表内关联

防止过度使用 enum




















